---
title: "Splinets Statistical Application: mass spectrometry"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Splinets Statistical Application: mass spectrometry}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Splinets)
```


# Introduction to Splinets

Examples of splines for non-equally spaced knots (first two figures) and equally spaced knots (right). Both individual splines and random spline samples generated around with a use of the implemented random spline generator. Vertical dashed lines in all figures are placed at the locations of the knots.

```{r, fig.width=8, fig.height=4}
n=20; k=3 #Number of knots and the order of splines
set.seed(10)
xi=sort(rbeta(n+2,2,5)); xi[1]=0; xi[n+1]=1 #Randomly distributed knots

S=matrix(rnorm((n+2)*(k+1)),ncol=(k+1)) #Random matrix of derivatives
spl=construct(xi,k,S) #A spline object with corrected matrix of the derivatives
plot(spl)
```


```{r, fig.width=8, fig.height=4}
y=rspline(spl,10) #Random spline generator
plot(y)
```


```{r, fig.width=8, fig.height=4}
xi2=seq(0,1,by=1/(n+1))
spl2=construct(xi2,k,S) #Another spline object
plot(spl2)
```


```{r, fig.width=8, fig.height=4}
y2=rspline(spl2,10) #Another random sample
plot(y2)
```

The result is shown in above demonstrate that the knot distribution is fundamental in shaping geometry of functional spaces. The difference in the nature of the two linear functional spaces observed  is obvious, as in the first twographs we see more capacity to focus on the localized variability and detail, the capacity that is lacked in splines in the right-hand side graphs. 


# Orthonormal bases of splines

```{r fig.width=8, fig.height=4}
k=3; N=5 #Order of splines and the number of layers
n=k*2^N-1 #Number of knots
set.seed(2)
xi=cumsum(runif(n+2,min=0.2)) #Random knots
so = splinet(xi, k) #Evaluation of the B-splines and the splinet

plot(so$bs,type='dyadic') #B-splines on the dyadic net
plot(so$os) #Splinet on the dyadic net
```

Cubic spline bases presented graphically in the sequential form (top) and on the dyadic net (bottom). The case of $n=k2^N-1=95$, $k=3$, $N=5$ which is the number of layers in the dyadic structure seen in the figures. The first is the B-spline basis; After is the corresponding splinet.

# Wine data set

```{r}
source("WineDataExampleAuxFunc.R")
```

```{r WineData}
library(DDK)
# get the data from the DKK pacakge
data("Wine")
f_data_wine <- Wine$x.learning
t_df_wine <- seq(1, dim(f_data_wine)[2])
# test data
f_data_wine_test <- Wine$x.test
t_df_wine_test <- seq(1, dim(f_data_wine_test)[2])
# remove raw 84 since it is an outlier
f_data_wine <- f_data_wine[-84,]
```

```{r KnotsPrepare}
# the knots are: 0  21  28  40  83 139 167 186 193 256
knots <- c(0, 21, 28, 40, 83, 139, 167, 186, 193, 256)
# prepare the knots
Wine_DDKnots <- Knots_prepare(selected_knots = knots, Time = t_df_wine)
n = length(Wine_DDKnots) - 1
```


```{r DataPrepare}
# prepare the data
Wine_prepared <- data_prepare(f_data = f_data_wine, t_data = t_df_wine)
```


```{r Projections}
# project the data and perfrom the eigen decomposition
# wine_proj = project(Wine_prepared, Wine_DDKnots) # Project wine data onto spline bases
# Sigma = cov(wine_proj$coeff)  # Covariance matrix of the projection coefficients
# Spect = eigen(Sigma, symmetric = T)  # eigen decomposition of the covariance matrix
# EigenSp = lincomb(wine_proj$basis, t(Spect$vec))  
# Create a functional eigenfunctions by linearly combining the splinets basis functions (from ProjObj$basis) with the eigenvectors (Spect$vec).

WineObj <- GetProjCovEig(f_ready_data = Wine_prepared, ready_knots = Wine_DDKnots)
```

```{r fig.width=8, fig.height=4}
plot_EigenfunctionEigenValueScaled(ProjCovEigObj = WineObj, EigenNumber = 3)    
```
```{r fig.width=8, fig.height=4}
C_mat_Wine=WineObj$ProjObj$coeff %*% WineObj$Spect$vec
EgenFunWine1 <- subsample(WineObj$EigenSp, 1)
{matplot(Wine_prepared[,1],Wine_prepared[,2],type='l',lty=1,xlab='',ylab='', bty="n", 
         col="deepskyblue4", xlim = c(-1.5,dim(f_data_wine)[2]))
             lines(WineObj$ProjObj$sp,sID=2-1,col='goldenrod',lty=1,lwd=1)
             lines(lincomb(EgenFunWine1,C_mat_Wine[1,1,drop=F]),col='darkorange3')
             abline(v = WineObj$EigenSp@knots, lty = 3, lwd = 0.5)}
```


<!-- ```{r} -->
<!-- C_mat_Wine=wine_proj$coeff %*% Spect$vec -->
<!-- EgenFunWine1 <- subsample(EigenSp, 1) -->
<!-- {matplot(Wine_prepared[,1],Wine_prepared[,2],type='l',lty=1,xlab='',ylab='', bty="n",  -->
<!--          col="deepskyblue4", xlim = c(-1.5,dim(f_data_wine)[2])) -->
<!--              lines(wine_proj$sp,sID=2-1,col='goldenrod',lty=1,lwd=1) -->
<!--              lines(lincomb(EgenFunWine1,C_mat_Wine[1,1,drop=F]),col='darkorange3') -->
<!--              abline(v = EigenSp@knots, lty = 3, lwd = 0.5)} -->
<!-- ``` -->


# INTRODUCTION 
An ovarian cancer tissue low-resolution SELDI-TOF mass spectrum (in orange) and its various representations as Splinet-objects in approximately 200 dimensional spline spaces: 


Reading a raw spectrum obtained from the original data set (A01.csv).

```{r}
#The file-path needs to be adequate to the location of data
# Path='../data/A01.csv'
Path='A01.csv'
Ovarian=read.table(Path,header=TRUE,sep=",",col.names=c('ms','Intensity'))
```


The original sample (orange) consisting of 15154 values. 

```{r, fig.width=8, fig.height=4}


plot(Ovarian$ms,Ovarian$Intensity,type='h',xlab='m/s',ylab='Intensity',col='orange',axes=FALSE)#,xaxt='n')
axis(1, at=seq(0, 20000, by=200),col = "blue")
axis(2, col = "blue")
```


The projection (navy-blue) to the spline space spanned on 200 equally spaced knots.

```{r, fig.width=8, fig.height=4}
#Equally spaced 200 knots,
xi1=seq(min(Ovarian$ms),max(Ovarian$ms),length.out=200)
so1 = splinet(xi1)  #Orthogonal basis of splines
OvSpl1=project(as.matrix(Ovarian),basis=so1$os) #Projection to the basis
#
plot(Ovarian$ms,Ovarian$Intensity,type='h',xlab='m/s',ylab='Intensity',col='orange',axes=FALSE)#,xaxt='n')
axis(1, at=seq(0, 20000, by=200),col = "blue")
axis(2, col = "blue")
lines(OvSpl1$sp)
```

The projection (red) to the spline space spanned on 200 non-equally spaced knots with their locations chosen by the spectrum.

```{r fig.width=8, fig.height=4}
wghts=abs(Ovarian$Intensity)/sum(abs(Ovarian$Intensity)) #Weights for knot selection
xi2=sort(sample(Ovarian$ms,200,prob=wghts)) #Random knots
         so2 = splinet(xi2) #Orthogonal basis of splines
         OvSpl2=project(as.matrix(Ovarian),basis=so2$os) #Projection to the basis
#
plot(Ovarian$ms,Ovarian$Intensity,type='h',xlab='m/s',ylab='Intensity',col='orange',axes=FALSE)#,xaxt='n')
axis(1, at=seq(0, 20000, by=200),col = "blue")
axis(2, col = "blue")
lines(OvSpl1$sp)
lines(OvSpl2$sp,col='red')
```

The projection to the splines with a sparse domain obtained by specifying five importance regions, with the graph above each of the five support intervals drawn by a different color.

```{r fig.width=8, fig.height=4}
xi3=seq(min(Ovarian$ms),max(Ovarian$ms),length.out=300)
so3 = splinet(xi3)
OvSpl3=project(as.matrix(Ovarian),basis=so3$os)

IndKn=1:length(OvSpl3$sp@knots)
Nsupp=5 #the number of support intervals
LE=c(700,6500,11400,13600,16500)
RE=c(5400,10800,12100,15900,18800)

OvSpl4=OvSpl3$sp
OvSpl4@supp=list()
for(l in 1:Nsupp){
  J=IndKn[OvSpl3$sp@knots>LE[l] & OvSpl3$sp@knots<RE[l]]
  OvSpl4@supp[[l]]=matrix(c(min(J),max(J)),nrow=1)
}

OvSpl4@der=list()
Der=sym2one(OvSpl3$sp@der[[1]])
for(l in 1:Nsupp){
  OvSpl4@der[[l]]=sym2one(Der[OvSpl4@supp[[l]][1,1]:OvSpl4@supp[[l]][1,2],],inv=TRUE)
}

OvSpl4@knots[c(OvSpl4@supp[[1]][1,1],OvSpl4@supp[[1]][1,2])]
OvSpl4@knots[c(OvSpl4@supp[[2]][1,1],OvSpl4@supp[[2]][1,2])]
OvSpl4@knots[c(OvSpl4@supp[[3]][1,1],OvSpl4@supp[[3]][1,2])]
OvSpl4@knots[c(OvSpl4@supp[[4]][1,1],OvSpl4@supp[[4]][1,2])]
OvSpl4@knots[c(OvSpl4@supp[[5]][1,1],OvSpl4@supp[[5]][1,2])]

plot(Ovarian$ms,Ovarian$Intensity,type='h',xlab='m/s',ylab='Intensity',col='grey',axes=FALSE)#,xaxt='n')
axis(1, at=seq(0, 20000, by=200),col = "blue")
axis(2, col = "blue")   
lines(OvSpl4)
```




